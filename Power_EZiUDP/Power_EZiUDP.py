# -*- coding: utf-8 -*-
"""
/***************************************************************************
Power_EZiUDP
                                 A QGIS plugin
Power_EZiUDP
 Generated by Plugin Builder
 ***************************************************************************/
"""

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QUrl, QStringListModel
from qgis.PyQt.QtGui import QIcon, QDesktopServices, QColor
from qgis.PyQt import QtWidgets
from qgis.core import (
    QgsRasterLayer, QgsVectorLayer, QgsProject, QgsFeatureRequest, QgsGeometry,
    QgsCoordinateTransform, QgsCoordinateReferenceSystem, QgsRectangle, QgsFeature, QgsMessageLog, Qgis
)
from qgis.PyQt.QtWidgets import QAction, QDialog, QVBoxLayout, QListWidget, QListWidgetItem, QPushButton, QCompleter, QApplication, QToolButton, QMenu
from qgis.gui import QgsMapToolEmitPoint, QgsRubberBand
import os.path, re, requests

from .resources import *
from .Power_EZiUDP_dockwidget import Power_EZiUDPDockwidget


# ===============================
# DIALOG WYBORU WARSTW
# ===============================
class LayerSelectionDialog(QDialog):
    def __init__(self, layers, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Wybierz warstwy do dodania")
        self.resize(400, 300)
        layout = QVBoxLayout(self)
        self.list_widget = QListWidget()
        for name, title in layers:
            item = QListWidgetItem(f"{title} ({name})")
            item.setFlags(item.flags() | Qt.ItemIsUserCheckable)
            item.setCheckState(Qt.Unchecked)
            self.list_widget.addItem(item)
        layout.addWidget(self.list_widget)
        self.btn_ok = QPushButton("Dodaj zaznaczone")
        self.btn_ok.clicked.connect(self.accept)
        layout.addWidget(self.btn_ok)

    def get_selected(self):
        selected = []
        for i in range(self.list_widget.count()):
            item = self.list_widget.item(i)
            if item.checkState() == Qt.Checked:
                selected.append(item.text())
        return selected


# ===============================
# NARZƒòDZIE KLIKNIƒòCIA NA MAPIE
# ===============================
class PointTool(QgsMapToolEmitPoint):
    def __init__(self, iface, callback):
        super().__init__(iface.mapCanvas())
        self.iface = iface
        self.callback = callback

    def canvasReleaseEvent(self, event):
        point = self.toMapCoordinates(event.pos())
        self.callback(point)
        self.iface.mapCanvas().unsetMapTool(self)


# ===============================
# FUNKCJE OBS≈ÅUGI GETCAPABILITIES
# ===============================
def fetch_capabilities(url: str):
    """Pobiera dokument GetCapabilities i zwraca listƒô nazw warstw oraz typ us≈Çugi."""
    try:
        if "SERVICE=WFS" in url.upper():
            service_type = "WFS"
        elif "SERVICE=WMS" in url.upper():
            service_type = "WMS"
        else:
            if "wfs" in url.lower():
                service_type = "WFS"
                url = url.split("?")[0]
                url += "?SERVICE=WFS&REQUEST=GetCapabilities"
            else:
                service_type = "WMS"
                url = url.split("?")[0]
                url += "?SERVICE=WMS&REQUEST=GetCapabilities"

        response = requests.get(url, timeout=10, verify=False)
        # response.raise_for_status()
        try:
            raw = response.content
            text = raw.decode('utf-8', errors='replace')
        except:
            text = response.text

        names = re.findall(r"<Name.*?>(.*?)</Name>", text)
        titles = re.findall(r"<Title.*?>(.*?)</Title>", text)
        if len(titles) > len(names):
            titles = titles[-len(names):]

        layers = list(zip(names, titles))
        return layers, service_type
    except Exception as e:
        print("B≈ÇƒÖd pobierania GetCapabilities:", e)
        return [], url


def add_layers_from_service(url: str, iface):
    layers, service_type = fetch_capabilities(url)
    if not layers:
        iface.messageBar().pushWarning("EZiUDP", f"Nie uda≈Ço siƒô pobraƒá listy warstw z\nURL:{service_type}")
        return

    dlg = LayerSelectionDialog(layers)
    if dlg.exec_():
        selected = dlg.get_selected()
        if not selected:
            iface.messageBar().pushInfo("EZiUDP", "Nie wybrano ≈ºadnych warstw.")
            return

        for layer_text in selected:
            m = re.search(r"\((.*?)\)$", layer_text)
            if not m:
                continue
            layer_name = m.group(1)

            if service_type == "WMS":
                clean_url = re.sub(r"[?&]request=GetCapabilities", "", url, flags=re.I)
                clean_url = re.sub(r"[?&]service=WMS", "", clean_url, flags=re.I)
                base_url = clean_url.split("?")[0]
                params = "?" + "&".join([p for p in clean_url.split("?")[1:] if p])
                if not params.endswith("&"):
                    params += "&"
                layer_url = f"url={base_url}{params}service=WMS&request=GetMap&layers={layer_name}&styles=&format=image/png&crs=EPSG:2180"
                # rlayer = QgsRasterLayer(layer_url, layer_name, "wms")
                # layer_url = f"{base_url}{params}&layers={layer_name}&styles=&format=image/png&crs=EPSG:2180"
                rlayer = QgsRasterLayer(layer_url, layer_name, "wms")
                if rlayer.isValid():
                    QgsProject.instance().addMapLayer(rlayer)
                else:
                    iface.messageBar().pushWarning("EZiUDP", f"Nie uda≈Ço siƒô dodaƒá WMS: {layer_name}")


            elif service_type == "WFS":
                layer_url = f"{url}?service=WFS&version=2.0.0&request=GetFeature&typeName={layer_name}"
                vlayer = QgsVectorLayer(layer_url, layer_name, "WFS")
                if vlayer.isValid():
                    QgsProject.instance().addMapLayer(vlayer)
                else:
                    layer_url = f"{url}?service=WFS&version=1.1.0&request=GetFeature&typeName={layer_name}"
                    vlayer = QgsVectorLayer(layer_url, layer_name, "WFS")
                    if vlayer.isValid():
                        QgsProject.instance().addMapLayer(vlayer)
                    else:
                        iface.messageBar().pushWarning("EZiUDP", f"Nie uda≈Ço siƒô dodaƒá WFS: {layer_name}")

def copy_to_clipboard(text: str):
    clipboard = QApplication.clipboard()
    clipboard.setText(text)

def create_action_button(url, iface):
    btn = QToolButton()
    btn.setText("Dodaj")
    btn.setPopupMode(QToolButton.MenuButtonPopup)

    # Menu rozwijane
    menu = QMenu()

    # Akcje
    add_action = QAction("Dodaj warstwy", btn)
    # add_wfs_action = QAction("Dodaj WFS", btn)
    copy_action = QAction("Kopiuj adres URL", btn)
    copy_gc = QAction("Kopiuj adres Get Capabilities", btn)
    # copy_wfs_action = QAction("Kopiuj adres WFS", btn)

    # Podpiƒôcie akcji
    btn.clicked.connect(lambda: add_layers_from_service(url, iface))
    add_action.triggered.connect(lambda: add_layers_from_service(url, iface))
    # add_wfs_action.triggered.connect(lambda: add_service_to_qgis(wfs_url, "WFS"))
    copy_gc.triggered.connect(lambda: copy_to_clipboard(url))
    copy_action.triggered.connect(lambda: copy_to_clipboard(url.split("?")[0] if "?" in url else url))
    # copy_wfs_action.triggered.connect(lambda: copy_to_clipboard(wfs_url))

    # Dodanie do menu
    menu.addAction(add_action)
    # menu.addAction(add_wfs_action)
    menu.addSeparator()
    menu.addAction(copy_gc)
    menu.addAction(copy_action)
    # menu.addAction(copy_wfs_action)

    btn.setMenu(menu)
    return btn

class TerytSelectionDialog(QDialog):
    """Okno wyboru jednostki TERYT z pod≈õwietleniem na mapie.
       Pokazuje na li≈õcie: TERYT ‚Äî NAZWA (RODZAJ)
    """
    def __init__(self, iface, layer, teryt_features):
        super().__init__()
        self.iface = iface
        self.layer = layer
        self.teryt_features = teryt_features  # lista QgsFeature
        self.setWindowTitle("Wyb√≥r jednostki TERYT")
        self.resize(420, 340)

        layout = QVBoxLayout()
        self.list_widget = QListWidget()
        # Wype≈Çnienie listy: poka≈º TERYT ‚Äî NAZWA (RODZAJ) je≈õli pola sƒÖ dostƒôpne
        for f in teryt_features:
            code = str(f["TERYT"]) if "TERYT" in f.fields().names() else ""
            name = str(f["NAZWA"]) if "NAZWA" in f.fields().names() else (str(f["NAZWA"]) if "Nazwa" in f.fields().names() else "")
            kind = str(f["RODZAJ"]) if "RODZAJ" in f.fields().names() else ""
            display = f"{code} ‚Äî {name}"
            if kind:
                display += f" ({kind})"
            self.list_widget.addItem(display)
        layout.addWidget(self.list_widget)

        self.btn_ok = QPushButton("Wybierz")
        self.btn_ok.clicked.connect(self.on_accept)
        layout.addWidget(self.btn_ok)
        self.setLayout(layout)

        # RubberBand do pod≈õwietlenia (p√≥≈Çprzezroczyste wype≈Çnienie + obw√≥dka)
        self.rubber = QgsRubberBand(self.iface.mapCanvas())#, geometryType=QgsRubberBand.Polygon)
        self.rubber.setFillColor(QColor(255, 255, 0, 80))   # p√≥≈Çprzezroczyste wype≈Çnienie
        self.rubber.setColor(QColor(255, 200, 0, 200))      # obw√≥dka
        self.rubber.setWidth(2)

        # Reakcja na zmianƒô wyboru
        self.list_widget.currentRowChanged.connect(self.highlight_feature)

    def highlight_feature(self, index):
        """Pod≈õwietla aktualnie zaznaczony obiekt i zoomuje do niego."""
        self.rubber.reset()
        if index < 0 or index >= len(self.teryt_features):
            return
        feature = self.teryt_features[index]
        geom = feature.geometry()
        if geom is None or geom.isEmpty():
            return
        self.rubber.setToGeometry(geom, self.layer)
        try:
            self.iface.mapCanvas().zoomToFeatureIds(self.layer, [feature.id()])
        except Exception:
            # fallback: ustaw widok na bounding box
            bbox = geom.boundingBox()
            self.iface.mapCanvas().setExtent(bbox)
            self.iface.mapCanvas().refresh()

    def get_selected_teryt(self):
        row = self.list_widget.currentRow()
        if row < 0:
            return None
        return str(self.teryt_features[row]["TERYT"])

    def on_accept(self):
        """Zatwierdzenie wyboru + wyczyszczenie zaznaczenia"""
        # resetuj wizualne zaznaczenie natychmiast
        try:
            self.rubber.reset()
        except Exception:
            pass
        self.accept()

    def closeEvent(self, event):
        try:
            self.rubber.reset()
        except Exception:
            pass
        super().closeEvent(event)



# ===============================
# G≈Å√ìWNA KLASA PLUGINU
# ===============================
class Power_EZiUDP:
    def __init__(self, iface):
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        self.actions = []
        self.menu = self.tr(u'&Power_EZiUDP')
        self.toolbar = self.iface.addToolBar(u'Power_EZiUDP')
        self.toolbar.setObjectName(u'Power_EZiUDP')
        self.pluginIsActive = False
        self.dockwidget = None
        self.debug = QSettings().value("Power_EZiUDP/debug", False, type=bool) # NEW
        # Wczytaj warstwƒô GeoJSON z TERYT (je≈õli istnieje)
        self.layer_teryt = None
        geojson_path = os.path.join(self.plugin_dir, "powiaty.geojson")
        if os.path.exists(geojson_path):
            self.layer_teryt = QgsVectorLayer(geojson_path, "TERYT_zasiegi", "ogr")
            

    def load_teryt_layer(self):
        rodzaj = self.dockwidget.comboBox.currentText()
        # poprawka wyszukujƒÖca tylko warstwy, kt√≥re powinnny byƒá
        if rodzaj in ["powiaty", "gminy", "wojewodztwa"]: 
            path = os.path.join(self.plugin_dir, f"{rodzaj}.geojson")
            self.layer_teryt = QgsVectorLayer(path, rodzaj, "ogr")

            if not self.layer_teryt.isValid():
                QtWidgets.QMessageBox.warning(None, "B≈ÇƒÖd", f"Nie uda≈Ço siƒô wczytaƒá warstwy {path}")


    def tr(self, message):
        return QCoreApplication.translate('Power_EZiUDP', message)

    def add_action(self, icon_path, text, callback, parent=None):
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        self.toolbar.addAction(action)
        self.iface.addPluginToMenu(self.menu, action)
        self.actions.append(action)
        return action

    def initGui(self):
        icon_path = ':/plugins/Power_EZiUDP/icon.png'
        self.add_action(icon_path, text=self.tr(u'EZiUDP'), callback=self.run, parent=self.iface.mainWindow())

    def onClosePlugin(self):
        """Reakcja na zamkniƒôcie dockwidgetu"""
        try:
            self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)
        except Exception:
            pass
        self.pluginIsActive = False
        if self.dockwidget:
            self.dockwidget.hide()

    
    def unload(self):
        self.pluginIsActive = False
        for action in self.actions:
            self.iface.removePluginMenu(self.menu, action)
            self.iface.removeToolBarIcon(action)
        del self.toolbar

    def log(self, message, level=Qgis.Info):
        """Loguje wiadomo≈õƒá je≈õli debug=True; zawsze drukuje do konsoli dla dev√≥w."""
        if self.debug:
            QgsMessageLog.logMessage(str(message), "Power_EZiUDP", level)
        else:
            # dla widoczno≈õci w konsoli programisty r√≥wnie≈º print
            print(message)

    def build_completer_for_layer(self):
        """Zbuduj i przypisz QCompleter do terytInput na podstawie obecnej layer_teryt."""
        if not hasattr(self, "layer_teryt") or self.layer_teryt is None or not self.layer_teryt.isValid():
            return
        names = []
        # preferowane pole nazwy: 'NAZWA' lub 'JPT_NAZWA_' lub 'nazwa'
        name_field = None
        for candidate in ("NAZWA","Nazwa"):
            if candidate in self.layer_teryt.fields().names():
                name_field = candidate
                break
        if not name_field:
            # fallback: nie buduj completera
            return
        for f in self.layer_teryt.getFeatures():
            val = f[name_field]
            if val:
                names.append(str(val))
        # unikalne i posortowane
        names = sorted(set(names), key=lambda s: s.lower())
        model = QStringListModel(names)
        completer = QCompleter()
        completer.setModel(model)
        completer.setCaseSensitivity(Qt.CaseInsensitive)
        completer.setFilterMode(Qt.MatchStartsWith)
        self.dockwidget.terytInput.setCompleter(completer)
        # zapamiƒôtaj referencjƒô je≈õli potrzeba
        self._teryt_completer = completer



    # ===============================
    # OBS≈ÅUGA KLIKNIƒòCIA I TERYT
    # ===============================
    def activate_point_tool(self):
        if not self.layer_teryt:
            QtWidgets.QMessageBox.warning(None, "Brak warstwy", "Brak warstwy GeoJSON z zasiƒôgami TERYT.")
            return
        
        self.iface.messageBar().pushMessage("EZiUDP", "Wska≈º punkt na mapie, aby ustaliƒá TERYT", duration=4)
        self.point_tool = PointTool(self.iface, self.point_selected)
        self.iface.mapCanvas().setMapTool(self.point_tool)

    def point_selected(self, point):
        print(f"Klikniƒôto: {point.x():.2f}, {point.y():.2f}")

        rodzaj = self.dockwidget.comboBox.currentText()
        # teryt = self.get_teryt_from_point(point, rodzaj)
        # self.dockwidget.lineEditTeryt.setText(teryt)

        # self.load_teryt_layer() nie ma potrszeby ≈Çadowania przy ka≈ºdym kliku

        if not self.layer_teryt:
            QtWidgets.QMessageBox.warning(None, "Brak warstwy", "Nie wczytano warstwy TERYT.")
            return

        crs_src = self.iface.mapCanvas().mapSettings().destinationCrs()
        crs_dst = self.layer_teryt.crs()
        transform = QgsCoordinateTransform(crs_src, crs_dst, QgsProject.instance())
        point_layer_crs = transform.transform(point)
        # geom = QgsGeometry.fromPointXY(point_layer_crs)

        # for f in self.layer_teryt.getFeatures(QgsFeatureRequest().setFilterRect(geom.boundingBox())):
        #     if f.geometry().intersects(geom):
        #         teryt = f["TERYT"]
        #         self.dockwidget.terytInput.setText(str(teryt))
        #         self.iface.messageBar().pushMessage("EZiUDP", f"Znaleziono jednostkƒô: {teryt}", duration=4)
        #         self.search_eziudp()
        #         return

        # Znajd≈∫ wszystkie obiekty, kt√≥re przecinajƒÖ punkt
        rect = QgsRectangle(point_layer_crs.x() - 0.01, point_layer_crs.y() - 0.01,
                            point_layer_crs.x() + 0.01, point_layer_crs.y() + 0.01)
        
        teryt_list = []
        for feat in self.layer_teryt.getFeatures(QgsFeatureRequest().setFilterRect(rect)):
            geom = feat.geometry()
            if geom.contains(point_layer_crs):
                teryt = feat["TERYT"] if "TERYT" in feat.fields().names() else None
                if teryt:
                    teryt_list.append(teryt)

        # Reakcja w zale≈ºno≈õci od liczby trafie≈Ñ
        if not teryt_list:
            QtWidgets.QMessageBox.information(None, "EZiUDP", "Nie znaleziono jednostki dla wskazanego punktu.")
            return
        
        if len(teryt_list) == 1:
            selected_teryt = teryt_list[0]
        else:
            # selected_teryt, ok = QtWidgets.QInputDialog.getItem(
            #    None,
            #    "Wyb√≥r jednostki",
            #    "Znaleziono kilka jednostek w otoczeniu wybranego punktu.\nWybierz numer TERYT:",
            #    teryt_list,
            #    0,
            #    False
            # )

            # Pobierz pe≈Çne featury zamiast samych kod√≥w
            features = []
            for feat in self.layer_teryt.getFeatures(QgsFeatureRequest().setFilterRect(rect)):
                geom = feat.geometry()
                if geom.contains(point_layer_crs):
                    features.append(feat)

            dlg = TerytSelectionDialog(self.iface, self.layer_teryt, features)
            if dlg.exec_():
                selected_teryt = dlg.get_selected_teryt()
                if not selected_teryt:
                    return
                    if not ok:
                        return


        # Ustaw numer w interfejsie
        self.dockwidget.terytInput.setText(selected_teryt)
        self.iface.messageBar().pushMessage("EZiUDP", f"Wybrano TERYT: {selected_teryt}", duration=4)
        self.search_eziudp()


        # QtWidgets.QMessageBox.information(None, "Brak", "Nie znaleziono jednostki administracyjnej dla tego punktu.")

    # ===============================
    # WYSZUKIWANIE EZiUDP
    # ===============================
    def search_eziudp(self):
        user_text = self.dockwidget.terytInput.text().strip()
        jedn = self.dockwidget.comboBox.currentText()
        zbior=""

        if not user_text:
            if jedn != "jednostki centralne":
                QtWidgets.QMessageBox.warning(None, "B≈ÇƒÖd", "Podaj numer TERYT lub nazwƒô jednostki.")
                # return

        if "#" in user_text:
            u_splt = user_text.split("#")
            zbior = u_splt[-1]
            user_text = u_splt[0]
            

            
        if re.search(r"[A-Za-zƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ªƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]", user_text):
            if jedn == "powiaty" and "powiat" not in user_text:
                sel = self.search_by_name_and_show_dialog(f"powiat {user_text}")
            else:
                sel = self.search_by_name_and_show_dialog(user_text)
            if not sel:
                return
            # sel jest teraz wybranym TERYT (kod). Kontynuuj dalej z sel jako teryt.
            teryt = sel
        else:
            # normalne zachowanie: interpretuj jako numer teryt
            teryt = user_text

        
        if jedn == "powiaty":
            if len(teryt) == 3:
                teryt = f"0{teryt}"
            teryt = teryt[:4]
        elif jedn == "wojewodztwa":
            teryt = teryt[:2]
        elif jedn == "gminy":
            teryt = teryt[:6]
        elif jedn == "jednostki centralne":
            jedn = "centralne"
            teryt = "PL"

        url = f"https://integracja.gugik.gov.pl/eziudp/index.php?teryt={teryt}&rodzaj={jedn}&nazwa=&zbior={zbior}&temat=&usluga=&adres="
        try:
            html = requests.get(url, timeout=10).text
        except Exception as e:
            QtWidgets.QMessageBox.critical(None, "B≈ÇƒÖd", f"Nie uda≈Ço siƒô pobraƒá danych:\n{e}")
            return

        rows = re.findall(r"<tr.*?>(.*?)</tr>", html, re.S | re.I)
        if not rows:
            QtWidgets.QMessageBox.warning(None, "Brak danych", "Nie znaleziono ≈ºadnych zbior√≥w dla tego TERYT.")
            return

        self.dockwidget.resultsTable.setRowCount(0)

        for row_html in rows[1:]:
            cols = re.findall(r"<td.*?>(.*?)</td>", row_html, re.S | re.I)
            if len(cols) < 2:
                continue
            nazwa = re.sub(r"<.*?>", "", cols[0]).strip()
            organ = re.sub(r"<.*?>", "", cols[1]).strip()
            rodzaj = re.sub(r"<.*?>", "", cols[2]).strip()
            teryt = re.sub(r"<.*?>", "", cols[3]).strip()
            wms_match = re.search(r'(https?://[^\s"\'<>]+?service=WMS[^\s"\'<>]*)', row_html, re.I)
            wfs_match = re.search(r'(https?://[^\s"\'<>]+?service=WFS[^\s"\'<>]*)', row_html, re.I)
            inspect_match = re.search(r'(index.php[^\s"\'<>]+?edycja[^\s"\'<>]*)', row_html, re.I)
            wms_url = wms_match.group(1) if wms_match else ""
            wfs_url = wfs_match.group(1) if wfs_match else ""
            inspect = inspect_match.group(1) if inspect_match else ""

            row = self.dockwidget.resultsTable.rowCount()
            self.dockwidget.resultsTable.insertRow(row)
            self.dockwidget.resultsTable.setItem(row, 0, QtWidgets.QTableWidgetItem(nazwa))
            self.dockwidget.resultsTable.setItem(row, 1, QtWidgets.QTableWidgetItem(organ))
            self.dockwidget.resultsTable.setItem(row, 2, QtWidgets.QTableWidgetItem(rodzaj))
            self.dockwidget.resultsTable.setItem(row, 3, QtWidgets.QTableWidgetItem(teryt))
            btn_wms = QtWidgets.QPushButton("")
            btn_wfs = QtWidgets.QPushButton("")
            btn_preview = QtWidgets.QPushButton("üåê")
            btn_inspect = QtWidgets.QPushButton("üìÉ")
            if wms_url:
                btn_wms = create_action_button(wms_url, self.iface)
                btn_wms.setIcon(QIcon(":/images/themes/default/mActionAddRasterLayer.svg"))
                # btn_wms.clicked.connect(lambda _, u=wms_url: add_layers_from_service(u, self.iface))
                btn_preview.clicked.connect(lambda _, t=teryt, u=wms_url: self.open_geoportal_preview(t, u))
            else:
                btn_wms.setEnabled(False)
                btn_preview.setEnabled(False)
            if wfs_url:
                btn_wfs = create_action_button(wfs_url, self.iface)
                btn_wfs.setIcon(QIcon(":/images/themes/default/mActionAddOgrLayer.svg"))
                # btn_wfs.clicked.connect(lambda _, u=wfs_url: add_layers_from_service(u, self.iface))
            else:
                btn_wfs.setEnabled(False)
            if inspect:
                inspect_url = f"https://integracja.gugik.gov.pl/eziudp/{inspect}"
                btn_inspect.clicked.connect(lambda _, i=inspect_url: QDesktopServices.openUrl(QUrl(i)))
            else:
                btn_inspect.setEnabled(False) 

            self.dockwidget.resultsTable.setCellWidget(row, 4, btn_wms)
            self.dockwidget.resultsTable.setCellWidget(row, 5, btn_wfs)
            self.dockwidget.resultsTable.setCellWidget(row, 6, btn_preview)
            self.dockwidget.resultsTable.setCellWidget(row, 7, btn_inspect)

    def search_by_name_and_show_dialog(self, name_query):
        """Szukaj w layer_teryt jednostek zaczynajƒÖcych siƒô od name_query (case-insensitive).
        Otw√≥rz TerytSelectionDialog z wynikami (TERYT, NAZWA, RODZAJ).
        """
        if not self.layer_teryt or not self.layer_teryt.isValid():
            QtWidgets.QMessageBox.warning(None, "Brak warstwy", "Nie wczytano warstwy jednostek.")
            return None

        # wybierz pole nazwy (tak jak w completer)
        name_field = None
        for candidate in ("NAZWA","JPT_NAZWA_","Nazwa","NAZWA_"):
            if candidate in self.layer_teryt.fields().names():
                name_field = candidate
                break
        if not name_field:
            QtWidgets.QMessageBox.information(None, "Brak pola nazwy", "Warstwa nie zawiera pola nazwy jednostki.")
            return None

        query = name_query.strip().lower()
        matches = []
        # filtr przestrzenny niepotrzebny ‚Äî przeszukujemy wszystkie cechy
        for feat in self.layer_teryt.getFeatures():
            val = feat[name_field]
            if val and str(val).lower().startswith(query):
                matches.append(feat)

        if not matches:
            QtWidgets.QMessageBox.information(None, "Brak wynik√≥w", f"Nie znaleziono jednostek zaczynajƒÖcych siƒô od '{name_query}'.")
            return None

        # otw√≥rz dialog do wyboru (z pod≈õwietleniem)
        dlg = TerytSelectionDialog(self.iface, self.layer_teryt, matches)
        if dlg.exec_():
            sel = dlg.get_selected_teryt()
            if sel:
                # ustaw w polu i zapisz do historii
                self.dockwidget.terytInput.setText(sel)
                # self.push_history(sel)
                # mo≈ºesz od razu wykonaƒá search_eziudp() dla sel ‚Äî lub zwr√≥ciƒá sel
                return sel
        return None


    def open_geoportal_preview(self, teryt, wms_url):
        """Otwiera podglƒÖd WMS w Geoportalu z bbox jednostki."""
        if not self.layer_teryt or not teryt:
            QtWidgets.QMessageBox.warning(None, "Brak danych", "Brak warstwy TERYT lub numeru.")
            return

        # Skr√≥ƒá TERYT w zale≈ºno≈õci od typu jednostki
        if len(teryt) >= 6:
            filter_prefix = teryt[:6]
        elif len(teryt) == 4:
            filter_prefix = teryt[:4]
        elif len(teryt) == 3:
            filter_prefix = f"0{teryt}"
        else:
            filter_prefix = teryt[:2]


        bbox = None
        for f in self.layer_teryt.getFeatures():
            val = str(f["TERYT"])
            if val.startswith(filter_prefix):
                geom = f.geometry()
                rect = geom.boundingBox()
                bbox = (rect.xMinimum(), rect.yMinimum(), rect.xMaximum(), rect.yMaximum())
                break

        
        if not bbox:
            # QtWidgets.QMessageBox.information(None, "Brak danych", f"Nie znaleziono zasiƒôgu dla TERYT {teryt}")
            url = f"https://mapy.geoportal.gov.pl/imap/Imgp_2.html?SRS=2180&resources=map:wms@{wms_url}"
            QDesktopServices.openUrl(QUrl(url))
            return

        bbox_str = ",".join([f"{c:.2f}" for c in bbox])
        url = f"https://mapy.geoportal.gov.pl/imap/Imgp_2.html?SRS=2180&resources=map:wms@{wms_url}&bbox={bbox_str}"

        QDesktopServices.openUrl(QUrl(url))

    def on_unit_type_changed(self, idx):
        self.load_teryt_layer()
        self.build_completer_for_layer()


    # ===============================
    # URUCHOMIENIE PLUGINU
    # ===============================
    def run(self):
        if not self.pluginIsActive:
            self.pluginIsActive = True
            if self.dockwidget is None:
                self.dockwidget = Power_EZiUDPDockwidget()
                self.dockwidget.searchButton.clicked.connect(self.search_eziudp)
                self.dockwidget.pointButton.clicked.connect(self.activate_point_tool)
                self.iface.addDockWidget(Qt.BottomDockWidgetArea, self.dockwidget)
                self.dockwidget.comboBox.currentIndexChanged.connect(self.on_unit_type_changed)
                self.build_completer_for_layer()

            self.dockwidget.show()
        else:
            self.dockwidget.show()
            self.dockwidget.raise_()

